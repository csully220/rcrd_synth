#include <SerLCD.h>
#include <LiquidCrystal_I2C.h>
#include <Wire.h>
#include "PinDefs.h"
#include "Comms.h"

int rcbl = 9; //rotary encoder bank limit
int rot_enc_ctr = 0;
int rot_enc_ctr_last = 0;
int sw_val_last;

void initInput();
bool updateInput();
void rotEncMovedLt();
void rotEncMovedRt();

SerLCD red_lcd(Serial1,16,2);    //RED ON BLACK LCD
LiquidCrystal_I2C blue_lcd(0x27,20,4); //BLUE ON WHITLE LCD

void setup()
{
  analogReference(EXTERNAL);
  attachInterrupt(0, rotEncMovedLt, RISING);
  attachInterrupt(1, rotEncMovedRt, RISING);
  
  Serial.begin(9600);
  Serial1.begin(9600); 
  blue_lcd.init(); //initialize the lcd
  blue_lcd.backlight(); //open the backlight

  red_lcd.begin();
  red_lcd.clear();
  red_lcd.print("Time to play!");
  initInput();
 }
/*********************************************************/
void loop() {
  
  if(updateInput()){
  
      //menu.disp_knob_vals(knob_values);
      delay(10);
      packKnobData();
      packSwData();
  
      for(int i=0; i<=7; i++){
          Serial.write(output_buf[i]);
      }
      Serial.print("\n");
    }  
    
    if(rot_enc_ctr != rot_enc_ctr_last){
        if(rot_enc_ctr < 0)  rot_enc_ctr = rcbl;
        if(rot_enc_ctr > rcbl) rot_enc_ctr = 0;
        //lcd1.clear();
        //lcd1.setPosition(0,0);
        //lcd1.print(sw_names[rot_enc_ctr]);
        rot_enc_ctr_last = rot_enc_ctr;
        //lcd1.setPosition(2,0);
        //lcd1.print(sw_values[rot_enc_ctr]);
        sw_val_last = sw_values[rot_enc_ctr];
    }
    //check if displayed switch has changed, update display if needed
    if(sw_values[rot_enc_ctr] != sw_val_last){
        //lcd1.setPosition(2,0);
        //lcd1.print(sw_values[rot_enc_ctr]);
        sw_val_last = sw_values[rot_enc_ctr];
    }
}  

//Interrupt functions for the rotary encoder
void rotEncMovedLt(){
  cli(); //stop interrupts happening before we read pin values
  reading = PINE & 0x30; // read all eight pin values then strip away all but pinA and pinB's values
  if(reading == B00110000 && aFlag) { //check that we have both pins at detent (HIGH) and that we are expecting detent on this pin's rising edge
    rot_enc_ctr --; //decrement the encoder's position count
    bFlag = 0; //reset flags for the next turn
    aFlag = 0; //reset flags for the next turn
  }
  else if (reading == B00010000) bFlag = 1; //signal that we're expecting pinB to signal the transition to detent from free rotation
  sei(); //restart interrupts
}

void rotEncMovedRt(){
  cli();
  reading = PINE & 0x30; //read all eight pin values then strip away all but pinA and pinB's values
  if (reading == B00110000 && bFlag) { //check that we have both pins at detent (HIGH) and that we are expecting detent on this pin's rising edge
    rot_enc_ctr ++; //increment the encoder's position count
    bFlag = 0; //reset flags for the next turn
    aFlag = 0; //reset flags for the next turn
  }
  else if (reading == B00100000) aFlag = 1; //signal that we're expecting pinA to signal the transition to detent from free rotation
  sei();
}
/************************************************************/
